import { Injectable, Logger } from '@nestjs/common';
import { MCPTool, MCPToolRegistry } from '../registry/tool.registry';
import { AwsService } from '@aws/aws.service';

@Injectable()
export class DocumentRetrievalTool {
  private readonly logger = new Logger(DocumentRetrievalTool.name);

  constructor(private readonly awsService: AwsService) {}

  async register(registry: MCPToolRegistry): Promise<void> {
    const tool: MCPTool = {
      name: 'retrieve-documentation',
      description: 'Retrieves or generates documentation for a specific component or entity',
      category: 'documentation',
      parameters: {
        type: 'object',
        required: ['entityId'],
        properties: {
          entityId: {
            type: 'string',
            description: 'ID of the entity to retrieve documentation for',
            required: true,
          },
          format: {
            type: 'string',
            description: 'Desired format of the documentation',
            enum: ['markdown', 'html', 'json'],
            default: 'markdown',
          },
          includeRelated: {
            type: 'boolean',
            description: 'Whether to include related entities in the documentation',
            default: false,
          },
        },
      },
      execute: this.execute.bind(this),
      timeout: 45000,
      retryable: true,
      cacheable: true,
    };

    registry.registerTool(tool);
  }

  private async execute(params: any): Promise<any> {
    const { entityId, format = 'markdown', includeRelated = false } = params;
    
    this.logger.log(`Retrieving documentation for entity: ${entityId}`);

    try {
      // Try to get existing documentation from S3
      const docKey = `documentation/${entityId}.${this.getFileExtension(format)}`;
      let content: string;
      
      try {
        content = await this.awsService.getFromS3(docKey);
      } catch (error) {
        // Generate new documentation if not found
        content = this.generateDocumentationTemplate(entityId, format);
        
        // Store generated documentation
        await this.awsService.storeInS3(docKey, content);
      }

      const result = {
        entityId,
        format,
        content,
        metadata: {
          title: `Documentation for ${entityId}`,
          lastUpdated: new Date().toISOString(),
          author: 'MCP Hybrid Server',
          version: '1.0.0',
        },
        relatedEntities: includeRelated ? await this.getRelatedEntities(entityId) : undefined,
        retrievedAt: new Date().toISOString(),
        storedAt: `s3://${docKey}`,
      };

      return result;
    } catch (error) {
      this.logger.error(`Error retrieving documentation for ${entityId}:`, error);
      throw new Error(`Documentation retrieval failed: ${error.message}`);
    }
  }

  private getFileExtension(format: string): string {
    const extensions: Record<string, string> = {
      markdown: 'md',
      html: 'html',
      json: 'json',
    };
    return extensions[format] || 'md';
  }

  private generateDocumentationTemplate(entityId: string, format: string): string {
    switch (format) {
      case 'markdown':
        return this.generateMarkdownTemplate(entityId);
      case 'html':
        return this.generateHtmlTemplate(entityId);
      case 'json':
        return this.generateJsonTemplate(entityId);
      default:
        return this.generateMarkdownTemplate(entityId);
    }
  }

  private generateMarkdownTemplate(entityId: string): string {
    return `# Documentation for ${entityId}

## Overview

This documentation was automatically generated for entity \`${entityId}\`.

## Description

*Description to be added*

## Usage

*Usage examples to be added*

## Related Components

*Related components to be added*

## API Reference

*API documentation to be added*

## Examples

*Code examples to be added*

## Notes

*Additional notes to be added*

---

*Last updated: ${new Date().toISOString()}*  
*Generated by: MCP Hybrid Server*
`;
  }

  private generateHtmlTemplate(entityId: string): string {
    return `<!DOCTYPE html>
<html>
<head>
    <title>Documentation for ${entityId}</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 40px; line-height: 1.6; }
        h1 { color: #333; border-bottom: 2px solid #eee; padding-bottom: 10px; }
        h2 { color: #666; margin-top: 30px; }
        code { background-color: #f4f4f4; padding: 2px 4px; border-radius: 3px; }
        .metadata { color: #666; font-size: 0.9em; margin-top: 40px; padding-top: 20px; border-top: 1px solid #eee; }
    </style>
</head>
<body>
    <h1>Documentation for ${entityId}</h1>
    
    <h2>Overview</h2>
    <p>This documentation was automatically generated for entity <code>${entityId}</code>.</p>
    
    <h2>Description</h2>
    <p><em>Description to be added</em></p>
    
    <h2>Usage</h2>
    <p><em>Usage examples to be added</em></p>
    
    <h2>Related Components</h2>
    <p><em>Related components to be added</em></p>
    
    <h2>API Reference</h2>
    <p><em>API documentation to be added</em></p>
    
    <h2>Examples</h2>
    <p><em>Code examples to be added</em></p>
    
    <h2>Notes</h2>
    <p><em>Additional notes to be added</em></p>
    
    <div class="metadata">
        <p><strong>Last updated:</strong> ${new Date().toISOString()}</p>
        <p><strong>Generated by:</strong> MCP Hybrid Server</p>
    </div>
</body>
</html>`;
  }

  private generateJsonTemplate(entityId: string): string {
    const template = {
      entityId,
      title: `Documentation for ${entityId}`,
      sections: [
        {
          title: 'Overview',
          content: `This documentation was automatically generated for entity ${entityId}.`
        },
        {
          title: 'Description',
          content: 'Description to be added'
        },
        {
          title: 'Usage',
          content: 'Usage examples to be added'
        },
        {
          title: 'Related Components',
          content: 'Related components to be added'
        },
        {
          title: 'API Reference',
          content: 'API documentation to be added'
        },
        {
          title: 'Examples',
          content: 'Code examples to be added'
        },
        {
          title: 'Notes',
          content: 'Additional notes to be added'
        }
      ],
      metadata: {
        lastUpdated: new Date().toISOString(),
        generatedBy: 'MCP Hybrid Server',
        version: '1.0.0'
      }
    };
    
    return JSON.stringify(template, null, 2);
  }

  private async getRelatedEntities(entityId: string): Promise<any[]> {
    // Mock implementation - in reality, this would query the knowledge graph
    return [
      {
        entityId: 'related-entity-1',
        entityType: 'function',
        relationshipType: 'calls',
      },
      {
        entityId: 'related-entity-2',
        entityType: 'class',
        relationshipType: 'inherits_from',
      },
    ];
  }
}
